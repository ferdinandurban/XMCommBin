// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)
// swift-module-flags: -target x86_64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name XMComm
import CocoaLumberjack
import CoreBluetooth
import CoreLocation
import CryptoSwift
import Dispatch
import Foundation
import MapKit
import RxBluetoothKit2
import RxCocoa
import RxSwift
import Security
import Swift
import SystemConfiguration
import UIKit
import UserNotifications
@_exported import XMComm
import _Concurrency
public enum BtConnectionState {
  case notAvailable, notConnected, btConnected, authorized, disconnecting, btConnecting
  public var isConnected: Swift.Bool {
    get
  }
  public var performingConnectionOrIsConnected: Swift.Bool {
    get
  }
  public static func == (a: XMComm.BtConnectionState, b: XMComm.BtConnectionState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RxSwift.ObservableType {
  public func xmDebug(_ anIdentifier: Swift.String? = nil, trimOutput aTrimOutput: Swift.Bool = false, file aFile: Swift.StaticString = #file, line aLine: Swift.Int = #line, function aFunction: Swift.StaticString = #function) -> RxSwift.Observable<Self.Element>
}
extension Swift.Array {
  public func splitBy(_ aSize: Swift.Int) -> [[Element]]
}
extension Swift.Array where Element : Swift.Comparable {
  public func index(_ anElements: [Element]) -> Swift.Array<Element>.Index?
}
extension Foundation.Timer {
  public class func schedule(delay: Foundation.TimeInterval, handler: @escaping (CoreFoundation.CFRunLoopTimer?) -> Swift.Void) -> Foundation.Timer?
  public class func schedule(repeatInterval interval: Foundation.TimeInterval, handler: @escaping (CoreFoundation.CFRunLoopTimer?) -> Swift.Void) -> Foundation.Timer?
}
extension RxSwift.Reactive where Base == XMComm.ErrorMessageCenter {
  public func messages(forVc aVcName: Swift.String?) -> RxSwift.Observable<XMComm.ErrorMessage>
}
extension Swift.UInt8 : XMComm.XMCommActionValueType {
  public func unsignedIntValue() -> Swift.UInt8
}
extension Swift.Int : XMComm.XMCommActionValueType {
  public func unsignedIntValue() -> Swift.UInt8
}
extension Swift.UInt64 {
  public static func from(bytes aBytes: [Swift.UInt8]) -> Swift.UInt64
  public func unsignedBoxValue(size aSize: Swift.Int, source aSource: XMComm.ValueSource, date aBoxDate: Foundation.Date) -> XMComm.BoxValue<Any>
  public func unknownValue(forSize aSize: Swift.Int) -> Swift.UInt64
  public func isUnknown(forSize aSize: Swift.Int) -> Swift.Bool
}
extension Swift.Int64 {
  public static func from(bytes aBytes: [Swift.UInt8]) -> Swift.Int64
  public func signedIntValue(forSize aSize: Swift.Int, source aSource: XMComm.ValueSource, date aDate: Foundation.Date) -> XMComm.BoxValue<Any>
  public func unknownValue(forSize aSize: Swift.Int) -> Swift.Int64
  public func isUnknown(forSize aSize: Swift.Int) -> Swift.Bool
}
extension Swift.String {
  public func dataFromHex() -> Foundation.Data?
}
public struct MonthHelpers {
  public var month: Swift.Int
  public var year: Swift.Int
  public init(month aMonth: Swift.Int, year aYear: Swift.Int)
  public func toDates() -> (start: Foundation.Date, end: Foundation.Date)
}
extension Swift.Bool : XMComm.XMCommActionValueType {
  public func unsignedIntValue() -> XMComm.UartByte
}
public enum CarMode : Swift.UInt64 {
  case unknown, standard, maintenance, immobilized, emergency, autoLock
  public init?(rawValue: Swift.UInt64)
  public typealias RawValue = Swift.UInt64
  public var rawValue: Swift.UInt64 {
    get
  }
}
open class XMCarDetail {
  open var id: Swift.Int?
  open var properties: [XMComm.XMCarPropertyItem]
  open var requestTakeOver: Swift.Bool
  open var lastUpdated: Foundation.Date?
  public init(id anId: Swift.Int?, properties aProperties: [XMComm.XMCarPropertyItem], lastUpdated aLastUpdated: Foundation.Date?, requestTakeOver aTakeOver: Swift.Bool)
  @objc deinit
}
extension Swift.UnsignedInteger {
  public var byteArray: [Swift.UInt8] {
    get
  }
  public init?(_ aBytes: [Swift.UInt8])
}
public struct XMInfo : Swift.Decodable {
  public var name: Swift.String?
  public var version: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
public struct XMError {
}
public protocol XMUserHintType {
  var status: Swift.Int? { get set }
  var idUser: Swift.String? { get set }
  var userMail: Swift.String? { get set }
  var userFirstSecondName: Swift.String? { get set }
}
public enum XMLoginError : Swift.Error {
  case invalidAuthenticationInfo
  case invalidPUK
  case pukNotAvailable
  case invalidPIN
  case invalidPINOverLimit
  case invalidPINBlock
  case invalidPINLength
  case pinNotAvailable
  case tokenNotAvailable
  case urlNotFound
  case systemError
  case blockedMobileDevice
  case invalidDevice
  case stolenDevice
  case unknownResponseCode
  public static func == (a: XMComm.XMLoginError, b: XMComm.XMLoginError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension XMComm.XMLoginError : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
public enum XMSerializationError : Swift.Error {
  case notValid
  case notDictionary
  public static func == (a: XMComm.XMSerializationError, b: XMComm.XMSerializationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum XMRestError : Swift.Error {
  case parsingError
  case serializationError
  case badRequest
  case unauthorized
  case forbidden
  case secureByAppForbidden
  case missingDeviceId
  case missingInstallationId
  case notConnected
  case serverNotResponding
  case newVersionRequired
  case notAllowedOnDemoAccount
  case noContent
  case carNotAuthorized
  case deviceNotAuthorized
  case stolenPhone
  case noConnectionToXmarton
  case unknownPushId
  public static func error(forHTTPStatusCode code: Swift.Int?, responseBody aBody: Any? = nil) -> XMComm.XMRestError
  public func outputError() -> Swift.Error
  public func shouldInterruptSubscribe() -> Swift.Bool
  public static func == (a: XMComm.XMRestError, b: XMComm.XMRestError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension XMComm.XMRestError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.String : XMComm.CommValueType {
  public init?(serverValue aServerValue: Swift.String)
  public init?(boxValue aBoxValue: [XMComm.UartByte], precision aPrecision: Swift.Int?, rawValueType aType: XMComm.BoxRawValueType)
}
public class DriverVO : XMComm.DriverType {
  public var idUser: Swift.String
  public var firstName: Swift.String
  public var lastName: Swift.String
  public var externalHash: Swift.String
  public var name: Swift.String
  required public init()
  public init(json aJson: XMComm.JSON)
  @objc deinit
}
public typealias UartByte = Swift.UInt8
public struct MessageProcessingResult : Swift.OptionSet {
  public static let notProcessedYet: XMComm.MessageProcessingResult
  public static let missingEnvelope: XMComm.MessageProcessingResult
  public static let missingAESKey: XMComm.MessageProcessingResult
  public static let failedToCreateAES: XMComm.MessageProcessingResult
  public static let nothingToDecrypt: XMComm.MessageProcessingResult
  public static let decryptionSuccessful: XMComm.MessageProcessingResult
  public static let wrongMessageSize: XMComm.MessageProcessingResult
  public static let failedToDecrypt: XMComm.MessageProcessingResult
  public static let invalidCrc: XMComm.MessageProcessingResult
  public static let wrongContentLength: XMComm.MessageProcessingResult
  public static let missingMessageNumber: XMComm.MessageProcessingResult
  public static let invalidMessageNumber: XMComm.MessageProcessingResult
  public var rawValue: Swift.UInt
  public init(rawValue aRawValue: Swift.UInt)
  public typealias ArrayLiteralElement = XMComm.MessageProcessingResult
  public typealias Element = XMComm.MessageProcessingResult
  public typealias RawValue = Swift.UInt
}
public protocol UartMessageType {
  var rawData: [XMComm.UartByte]? { get }
  var rawContentData: [XMComm.UartByte]? { get }
  var contentData: [XMComm.UartByte]? { get }
  var isEncrypted: Swift.Bool { get set }
  var processingResult: XMComm.MessageProcessingResult { get }
  var rawDataDebug: Swift.String { get }
}
public enum ValueRequestType {
  case get, subscribe, unsubscribe
  public static func == (a: XMComm.ValueRequestType, b: XMComm.ValueRequestType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ValueRequest {
}
public struct CarCommandRequest {
}
public protocol UartMessageOutgoingType : XMComm.UartMessageType {
  var carCommand: XMComm.CarCommandRequest? { get }
  var valueRequests: [XMComm.ValueRequest]? { get }
  var packets: [[XMComm.UartByte]] { get }
  init(command aCommand: XMComm.CarCommandRequest)
  init(valueRequests aRequests: [XMComm.ValueRequest])
  init(handshakeData aHandshakeData: [XMComm.UartByte])
  init(authorizationWithMobileDeviceGuid aMobileDeviceGuid: [XMComm.UartByte])
  init(authorizationWithMobileDeviceGuid aMobileDeviceGuid: [XMComm.UartByte], temporaryKeys aTemporaryKeys: [[XMComm.UartByte]])
}
public struct UartValue {
  public static let subscribeFlag: XMComm.UartByte
  public static let paddingByte: XMComm.UartByte
  public let id: XMComm.UartByte
  public let bytes: [XMComm.UartByte]
  public var isAcknowledgeValue: Swift.Bool {
    get
  }
}
open class XMBoxInfoItem : XMComm.CarBoxInfoType {
  open var publicID: Swift.String
  open var publicKey: Swift.String
  open var authorizationState: XMComm.CarBoxStatus
  open var installationDate: Foundation.Date?
  open var btBoxUUID: Swift.String?
  open var temporaryKeys: [Foundation.Data]
  public init?(json aJSON: XMComm.JSON)
  public init(boxInfo aBoxInfo: XMComm.CarBoxInfoType)
  public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers open class DrivePointVO : XMComm.DrivePointType {
  open var idCar: Swift.Int?
  open var speed: CoreLocation.CLLocationSpeed?
  open var timestamp: Foundation.TimeInterval?
  open var coordinate: CoreLocation.CLLocationCoordinate2D
  open var addressLines: XMComm.AddressLinesType? {
    get
    set
  }
  required public init()
  required public init?(serverValue aServerValue: Swift.String)
  required public init?(boxValue aBoxValue: [XMComm.UartByte], precision aPrecision: Swift.Int?, rawValueType aType: XMComm.BoxRawValueType)
  convenience required public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
  @objc deinit
}
extension XMComm.DrivePointVO : XMComm.Cacheable {
  public var cacheRepresentation: Swift.String? {
    get
  }
}
extension XMComm.DrivePointVO : XMComm.CommValueType {
}
public class XMCarPropertyItem {
  public typealias Value = Swift.String
  open var key: Swift.String
  open var value: XMComm.XMCarPropertyItem.Value
  open var changedOn: Foundation.Date
  open var lastUpdated: Foundation.Date?
  open var boolValue: XMComm.BoxValue<Any> {
    get
  }
  public init(key aKey: Swift.String, value aValue: XMComm.XMCarPropertyItem.Value, changedOn aChangedOn: Foundation.Date, lastUpdated aLastUpdated: Foundation.Date?)
  public func unsignedIntValue(size aSize: Swift.Int) -> XMComm.BoxValue<Any>
  public func signedIntValue() -> XMComm.BoxValue<Any>
  @objc deinit
}
public enum CarBoxStatus : Swift.Int, Swift.Decodable {
  case unknown, notAuthorized, awaitingAuthorization, authorized
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension XMComm.CarBoxStatus : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct XMCarCapabilityItem : XMComm.CarCapabilityType {
  public var identifier: Swift.Int
  public var boxProperties: [XMComm.BoxPropertyType]
  public init?(json aJson: XMComm.JSON)
}
public struct XMBoxProperty : XMComm.BoxPropertyType {
  public var key: Swift.String
  public var accessibleViaGsm: Swift.Bool
  public var canBeChangedViaGsm: Swift.Bool
  public var accessibleViaBt: Swift.Bool
  public var canBeChangedViaBt: Swift.Bool
  public init?(json aJson: XMComm.JSON)
  public init(property aProperty: XMComm.BoxPropertyType)
}
extension Swift.Int {
  public func format(_ aFormat: Swift.String) -> Swift.String
}
extension Swift.Double {
  public func format(_ aFormat: Swift.String) -> Swift.String
}
extension Swift.Double {
  public var timeComponents: Foundation.DateComponents {
    get
  }
  public func formatString(includeSeconds aSeconds: Swift.Bool = false, lessThanMinuteText aSmallTime: Swift.String? = nil) -> Swift.String
}
extension Swift.Double {
  public func format() -> Swift.String
  public func formatWithUnits() -> (Swift.String, Swift.String)
}
open class XMCarItemDetail {
  open var carId: Swift.Int?
  open var fullModelName: Swift.String?
  open var registrationNumber: Swift.String?
  open var nick: Swift.String?
  open var gsmOnline: Swift.Bool?
  open var btOnline: Swift.Bool?
  open var location: XMComm.DrivePointVO?
  open var properties: XMComm.XMCarPropertyItem?
  open var tankCapacity: Swift.Int?
  open var pricePerKm: Swift.Double?
  open var boxInfo: XMComm.CarBoxInfoType?
  open var autoConnect: Swift.Bool
  open var currencyCode: Swift.String
  open var favourite: Swift.Bool?
  open var requestTakeover: Swift.Bool
  open var capabilities: [XMComm.BoxPropertyType] {
    get
  }
  public init?(json: XMComm.JSON)
  public init(car aCar: XMComm.CarType)
  public init()
  @objc deinit
}
extension XMComm.XMCarItemDetail : XMComm.CarWithBoxType {
  public var isFavourite: Swift.Bool {
    get
    set(aNewValue)
  }
  public var communicationState: XMComm.CarCommunicationState {
    get
    set(aNewValue)
  }
  public var nickName: Swift.String? {
    get
    set
  }
  public var id: Swift.Int {
    get
  }
  public var isRequestTakeover: Swift.Bool {
    get
  }
}
open class XMCarStatusParameterItem {
  open var carParameterName: Swift.String?
  open var carParameterBooleanStatus: Swift.Bool?
  open var carParameterValue: Swift.Double?
  open var carParameterUpdateTime: Foundation.Date?
  public init?(json: XMComm.JSON)
  @objc deinit
}
public enum OSType : Swift.String {
  case iOS
  case Android
  case WP
  case Unknown
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct DeviceInformation {
  public var device: XMComm.Device
  public var maker: Swift.String
  public var platform: XMComm.OSType
  public var appVersion: Swift.String
  public var model: Swift.String
  public var operatingSystemVersion: Swift.String
  public init()
  public init(installId anInstallId: Swift.String, device aDevice: XMComm.Device? = nil, model aModel: Swift.String? = nil, operatingSystemVersion aSystemVersion: Swift.String? = nil)
}
@_inheritsConvenienceInitializers open class DriveDetailVO : XMComm.DriveVO, XMComm.DriveDetailType {
  open var distanceCost: Swift.Double
  open var averageSpeed: Swift.Double
  open var maxSpeed: Swift.Double
  open var points: [XMComm.DrivePointType]
  open var startPoint: XMComm.DrivePointType?
  open var routeType: Swift.Int
  open var startLatitude: Swift.Double
  open var startLongitude: Swift.Double
  open var driver: Swift.String
  open var routeTypeName: Swift.String
  open var canEdit: Swift.Bool
  open var userName: Swift.String
  required public init()
  override public init?(json aJson: XMComm.JSON)
  @objc deinit
}
open class DriveVO : XMComm.DriveType {
  open var carId: Swift.Int
  open var id: Swift.Int?
  open var startDate: Foundation.Date
  open var endDate: Foundation.Date
  open var distance: Swift.Double
  open var startPlace: Swift.String
  open var endPlace: Swift.String
  open var ongoing: Swift.Bool
  open var driverId: Swift.String?
  open var duration: Foundation.TimeInterval?
  open var privateLevel: XMComm.PrivateLevel
  open var purpose: Swift.String?
  open var startAddress: XMComm.AddressLinesType? {
    get
    set
  }
  open var endAddress: XMComm.AddressLinesType? {
    get
    set
  }
  required public init()
  public init?(json aJson: XMComm.JSON)
  @objc deinit
}
public struct DriveListVO {
  public var totalDistance: Swift.Double?
  public var drives: [XMComm.DriveVO]
  public var carId: Swift.Int?
  public init(json aJson: XMComm.JSON)
  public init(json aJson: XMComm.JSON, carId aCarId: Swift.Int)
}
public enum Device {
  case iPodTouch5
  case iPodTouch6
  case iPodTouch7
  case iPhone4
  case iPhone4s
  case iPhone5
  case iPhone5c
  case iPhone5s
  case iPhone6
  case iPhone6Plus
  case iPhone6s
  case iPhone6sPlus
  case iPhone7
  case iPhone7Plus
  case iPhoneSE
  case iPhone8
  case iPhone8Plus
  case iPhoneX
  case iPhoneXS
  case iPhoneXSMax
  case iPhoneXR
  case iPhone11
  case iPhone11Pro
  case iPhone11ProMax
  case iPhoneSE2
  case iPhone12
  case iPhone12Mini
  case iPhone12Pro
  case iPhone12ProMax
  case iPhone13
  case iPhone13Mini
  case iPhone13Pro
  case iPhone13ProMax
  case iPad2
  case iPad3
  case iPad4
  case iPadAir
  case iPadAir2
  case iPad5
  case iPad6
  case iPadAir3
  case iPad7
  case iPad8
  case iPad9
  case iPadAir4
  case iPadMini
  case iPadMini2
  case iPadMini3
  case iPadMini4
  case iPadMini5
  case iPadMini6
  case iPadPro9Inch
  case iPadPro12Inch
  case iPadPro12Inch2
  case iPadPro10Inch
  case iPadPro11Inch
  case iPadPro12Inch3
  case iPadPro11Inch2
  case iPadPro12Inch4
  case iPadPro11Inch3
  case iPadPro12Inch5
  case homePod
  indirect case simulator(XMComm.Device)
  case unknown(Swift.String)
  public static var current: XMComm.Device {
    get
  }
  public static var identifier: Swift.String
  public static func mapToDevice(identifier: Swift.String) -> XMComm.Device
  public static func realDevice(from device: XMComm.Device) -> XMComm.Device
  public var diagonal: Swift.Double {
    get
  }
  public var screenRatio: (width: Swift.Double, height: Swift.Double) {
    get
  }
  public static var allPods: [XMComm.Device] {
    get
  }
  public static var allPhones: [XMComm.Device] {
    get
  }
  public static var allPads: [XMComm.Device] {
    get
  }
  @available(*, deprecated, renamed: "allDevicesWithSensorHousing")
  public static var allXSeriesDevices: [XMComm.Device] {
    get
  }
  public static var allPlusSizedDevices: [XMComm.Device] {
    get
  }
  public static var allProDevices: [XMComm.Device] {
    get
  }
  public static var allMiniDevices: [XMComm.Device] {
    get
  }
  public static var allSimulatorPods: [XMComm.Device] {
    get
  }
  public static var allSimulatorPhones: [XMComm.Device] {
    get
  }
  public static var allSimulatorPads: [XMComm.Device] {
    get
  }
  public static var allSimulatorMiniDevices: [XMComm.Device] {
    get
  }
  @available(*, deprecated, renamed: "allSimulatorDevicesWithSensorHousing")
  public static var allSimulatorXSeriesDevices: [XMComm.Device] {
    get
  }
  public static var allSimulatorPlusSizedDevices: [XMComm.Device] {
    get
  }
  public static var allSimulatorProDevices: [XMComm.Device] {
    get
  }
  public var isPod: Swift.Bool {
    get
  }
  public var isPhone: Swift.Bool {
    get
  }
  public var isPad: Swift.Bool {
    get
  }
  public var isSimulator: Swift.Bool {
    get
  }
  public var realDevice: XMComm.Device {
    get
  }
  public var isZoomed: Swift.Bool? {
    get
  }
  public static var allTouchIDCapableDevices: [XMComm.Device] {
    get
  }
  public static var allFaceIDCapableDevices: [XMComm.Device] {
    get
  }
  public static var allBiometricAuthenticationCapableDevices: [XMComm.Device] {
    get
  }
  public var isTouchIDCapable: Swift.Bool {
    get
  }
  public var isFaceIDCapable: Swift.Bool {
    get
  }
  public var hasBiometricSensor: Swift.Bool {
    get
  }
  public static var allDevicesWithSensorHousing: [XMComm.Device] {
    get
  }
  public static var allSimulatorDevicesWithSensorHousing: [XMComm.Device] {
    get
  }
  public var hasSensorHousing: Swift.Bool {
    get
  }
  public static var allDevicesWithRoundedDisplayCorners: [XMComm.Device] {
    get
  }
  public var hasRoundedDisplayCorners: Swift.Bool {
    get
  }
  public static var allDevicesWith3dTouchSupport: [XMComm.Device] {
    get
  }
  public var has3dTouchSupport: Swift.Bool {
    get
  }
  public static var allDevicesWithWirelessChargingSupport: [XMComm.Device] {
    get
  }
  public var supportsWirelessCharging: Swift.Bool {
    get
  }
  public static var allDevicesWithALidarSensor: [XMComm.Device] {
    get
  }
  public var hasLidarSensor: Swift.Bool {
    get
  }
  public static var allRealDevices: [XMComm.Device] {
    get
  }
  public static var allSimulators: [XMComm.Device] {
    get
  }
  public func isOneOf(_ devices: [XMComm.Device]) -> Swift.Bool
  public var name: Swift.String? {
    get
  }
  public var systemName: Swift.String? {
    get
  }
  public var systemVersion: Swift.String? {
    get
  }
  public var model: Swift.String? {
    get
  }
  public var localizedModel: Swift.String? {
    get
  }
  public var ppi: Swift.Int? {
    get
  }
  public var isGuidedAccessSessionActive: Swift.Bool {
    get
  }
  public var screenBrightness: Swift.Int {
    get
  }
}
extension XMComm.Device : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public var safeDescription: Swift.String {
    get
  }
}
extension XMComm.Device : Swift.Equatable {
  public static func == (lhs: XMComm.Device, rhs: XMComm.Device) -> Swift.Bool
}
@available(iOS 8.0, watchOS 4.0, *)
extension XMComm.Device {
  public enum BatteryState : Swift.CustomStringConvertible, Swift.Equatable {
    case full
    case charging(Swift.Int)
    case unplugged(Swift.Int)
    public var lowPowerMode: Swift.Bool {
      get
    }
    public var description: Swift.String {
      get
    }
  }
  public var batteryState: XMComm.Device.BatteryState? {
    get
  }
  public var batteryLevel: Swift.Int? {
    get
  }
}
@available(iOS 8.0, watchOS 4.0, *)
extension XMComm.Device.BatteryState : Swift.Comparable {
  public static func == (lhs: XMComm.Device.BatteryState, rhs: XMComm.Device.BatteryState) -> Swift.Bool
  public static func < (lhs: XMComm.Device.BatteryState, rhs: XMComm.Device.BatteryState) -> Swift.Bool
}
extension XMComm.Device {
  public enum Orientation {
    case landscape
    case portrait
    public static func == (a: XMComm.Device.Orientation, b: XMComm.Device.Orientation) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var orientation: XMComm.Device.Orientation {
    get
  }
}
extension XMComm.Device {
  public static var volumeTotalCapacity: Swift.Int? {
    get
  }
  public static var volumeAvailableCapacity: Swift.Int? {
    get
  }
  @available(iOS 11.0, *)
  public static var volumeAvailableCapacityForImportantUsage: Swift.Int64? {
    get
  }
  @available(iOS 11.0, *)
  public static var volumeAvailableCapacityForOpportunisticUsage: Swift.Int64? {
    get
  }
  @available(iOS 11.0, *)
  public static var volumes: [Foundation.URLResourceKey : Swift.Int64]? {
    get
  }
}
extension XMComm.Device {
  public struct ApplePencilSupport : Swift.OptionSet {
    public var rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let firstGeneration: XMComm.Device.ApplePencilSupport
    public static let secondGeneration: XMComm.Device.ApplePencilSupport
    public typealias ArrayLiteralElement = XMComm.Device.ApplePencilSupport
    public typealias Element = XMComm.Device.ApplePencilSupport
    public typealias RawValue = Swift.UInt
  }
  public static var allApplePencilCapableDevices: [XMComm.Device] {
    get
  }
  public var applePencilSupport: XMComm.Device.ApplePencilSupport {
    get
  }
}
extension XMComm.Device {
  public enum CameraType {
    @available(*, deprecated, renamed: "wide")
    case normal
    case wide
    case telephoto
    case ultraWide
    public static func == (a: XMComm.Device.CameraType, b: XMComm.Device.CameraType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var cameras: [XMComm.Device.CameraType] {
    get
  }
  public static var allDevicesWithCamera: [XMComm.Device] {
    get
  }
  @available(*, deprecated, renamed: "allDevicesWithWideCamera")
  public static var allDevicesWithNormalCamera: [XMComm.Device] {
    get
  }
  public static var allDevicesWithWideCamera: [XMComm.Device] {
    get
  }
  public static var allDevicesWithTelephotoCamera: [XMComm.Device] {
    get
  }
  public static var allDevicesWithUltraWideCamera: [XMComm.Device] {
    get
  }
  public var hasCamera: Swift.Bool {
    get
  }
  @available(*, deprecated, renamed: "hasWideCamera")
  public var hasNormalCamera: Swift.Bool {
    get
  }
  public var hasWideCamera: Swift.Bool {
    get
  }
  public var hasTelephotoCamera: Swift.Bool {
    get
  }
  public var hasUltraWideCamera: Swift.Bool {
    get
  }
}
public struct FuelListVO {
  public var fuels: [XMComm.FuelType]
  public init(json aJson: XMComm.JSON)
}
public struct FuelDetailItemVO : XMComm.FuelDetailType {
  public var carId: Swift.Int
  public var id: Swift.Int
  public var date: Foundation.Date
  public var type: Swift.String?
  public var volume: Swift.Double
  public var address: Swift.String?
  public var totalPrice: Swift.Double
  public var fullTank: Swift.Bool
  public var verified: Swift.Bool
  public var location: CoreLocation.CLLocationCoordinate2D?
  public var unitPrice: Swift.Double?
  public var currencyCode: Swift.String
  public var addressDetail: XMComm.AddressLinesType? {
    get
    set
  }
  public init()
  public init?(json aJson: XMComm.JSON)
}
public struct FuelItemVO : XMComm.FuelType {
  public var carId: Swift.Int
  public var id: Swift.Int
  public var date: Foundation.Date
  public var type: Swift.String?
  public var volume: Swift.Double
  public var address: Swift.String?
  public var totalPrice: Swift.Double?
  public var addressDetail: XMComm.AddressLinesType? {
    get
    set
  }
  public init?(json aJson: XMComm.JSON)
  public init?(json aJson: XMComm.JSON, carId aCarId: Swift.Int)
  public init()
}
public struct FuelStorageVO {
  public var id: Swift.Int
  public var capacity: Swift.Double?
  public var type: XMComm.FuelStorageTypeVO
  public var dictionary: [Swift.String : Any] {
    get
  }
}
@_hasMissingDesignatedInitializers open class RoadTypeRelatedValuesVO {
  open var general: Swift.Double?
  open var town: Swift.Double?
  open var outOfTown: Swift.Double?
  open var dictionary: [Swift.String : Any] {
    get
  }
  @objc deinit
}
public struct FuelInfoVO {
  public var idCar: Swift.Int?
  public var storage: XMComm.FuelStorageVO
  public var costs: XMComm.FuelCostsVO
  public var consumption: XMComm.FuelConsumptionVO
  public var currentLevel: Swift.Double?
  public var fuelName: Swift.String?
  public var fuelCode: Swift.String?
  public var dictionary: [Swift.String : Any] {
    get
  }
}
public struct FuelStorageTypeVO {
  public var name: Swift.String
  public var unit: Swift.String
  public var dictionary: [Swift.String : Any] {
    get
  }
}
open class XMCarTempKeyResponse {
  open var idCar: Swift.Int?
  open var temporaryKey: Swift.String?
  public init?(json: XMComm.JSON)
  @objc deinit
}
public enum PrivateLevel : Swift.UInt {
  case showEverything, hideDestinationAndTimes, hideDestinations
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
public struct CarCommunicationState : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue aRawValue: Swift.Int)
  public static let notAvailable: XMComm.CarCommunicationState
  public static let gsmAvailable: XMComm.CarCommunicationState
  public static let bluetoothAvailable: XMComm.CarCommunicationState
  public static let allConnectionAvailable: XMComm.CarCommunicationState
  public var isAvailable: Swift.Bool {
    get
  }
  public typealias ArrayLiteralElement = XMComm.CarCommunicationState
  public typealias Element = XMComm.CarCommunicationState
  public typealias RawValue = Swift.Int
}
extension XMComm.CarCommunicationState : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol CarType {
  var id: Swift.Int { get }
  var registrationNumber: Swift.String? { get }
  var communicationState: XMComm.CarCommunicationState { get set }
  var fullModelName: Swift.String? { get }
  var nickName: Swift.String? { get set }
  var capabilities: [XMComm.BoxPropertyType] { get }
  var currencyCode: Swift.String { get }
  var isFavourite: Swift.Bool { get set }
  var requestTakeover: Swift.Bool { get set }
}
extension XMComm.CarType {
  public var displayTitle: Swift.String? {
    get
  }
}
public protocol CarBoxInfoType : Swift.CustomDebugStringConvertible {
  var publicID: Swift.String { get set }
  var publicKey: Swift.String { get set }
  var authorizationState: XMComm.CarBoxStatus { get set }
  var btBoxUUID: Swift.String? { get set }
  var temporaryKeys: [Foundation.Data] { get set }
}
extension XMComm.CarBoxInfoType {
  public var debugDescription: Swift.String {
    get
  }
  public mutating func update(with anCarBoxInfoType: XMComm.CarBoxInfoType)
}
public protocol CarWithBoxType : Swift.CustomDebugStringConvertible, XMComm.CarType {
  var boxInfo: XMComm.CarBoxInfoType? { get set }
  var autoConnect: Swift.Bool { get set }
}
extension XMComm.CarWithBoxType {
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.String {
  public func objcRange(from aRange: Swift.Range<Swift.String.Index>) -> Foundation.NSRange
  public func range(from aObjcRange: Foundation.NSRange) -> Swift.Range<Swift.String.Index>?
}
open class XMCarSubscribeResponse {
  open var expiration: Swift.Int?
  public init?(json: XMComm.JSON)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class RestResponse {
  public var code: XMComm.RestResponseCode
  public var message: Swift.String?
  public var id: Swift.Int?
  public var idText: Swift.String?
  public var data: [Swift.String : Any]?
  @objc deinit
}
open class XMNotifRegistrationResponse {
  open var notificationID: Swift.String
  public init?(json: XMComm.JSON)
  @objc deinit
}
public struct XMLoginResponse {
  public var accessToken: Swift.String
  public var accessTokenExpire: Foundation.Date
  public var refreshToken: Swift.String
  public var refreshTokenExpire: Foundation.Date
  public var userGuid: Swift.String?
  public var code: XMComm.RestResponseCode
  public var message: Swift.String?
}
extension Foundation.URLError {
  public var rest: XMComm.XMRestError {
    get
  }
}
public enum BatteryStateDetail : Swift.UInt64 {
  case charged0
  case charged5
  case charged10
  case charged15
  case charged20
  case charged25
  case charged30
  case charged35
  case charged40
  case charged45
  case charged50
  case charged55
  case charged60
  case charged65
  case charged70
  case charged75
  case charged80
  case charged85
  case charged90
  case charged95
  case charged100
  public var category: XMComm.BatteryStateCategory {
    get
  }
  public var simplifiedCategory: XMComm.BatteryStateCategorySimplified {
    get
  }
  public init?(rawValue: Swift.UInt64)
  public typealias RawValue = Swift.UInt64
  public var rawValue: Swift.UInt64 {
    get
  }
}
public enum BatteryStateCategory : Swift.UInt64 {
  case unknown, full, threeQuarter, twothrees, half, discharged, requireService, damaged
  public init?(rawValue: Swift.UInt64)
  public typealias RawValue = Swift.UInt64
  public var rawValue: Swift.UInt64 {
    get
  }
}
public enum BatteryStateCategorySimplified : Swift.UInt64 {
  case unknown, error, warning, normal
  public init?(rawValue: Swift.UInt64)
  public typealias RawValue = Swift.UInt64
  public var rawValue: Swift.UInt64 {
    get
  }
}
public enum CarCommandId : Swift.Int {
  case openWindows
  case turnOnLights
  case unlockCar
  case turnOnWarningLights
  case authorizeByDeviceName
  case driverIdentification
  case switchCarMode
  case openRearLeft
  case openRearRight
  case secureByApp
  case notificationCarStart
  case notificationUnidentifiedDriver
  case notificationUnauthorizedOpen
  case notificationUnauthorizedEnter
  case notificationTowing
  case automaticStart
  case carManualStart
  case engineStart
  case phoneBatteryLevel
  case allowAutoLockOnDisconnect
  case sirene
  case trunkDoors
  case horn
  case turnOnHeating
  public static let allValue: [XMComm.CarCommandId]
  public var definition: XMComm.CommCommandDefinitionType {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension XMComm.CarCommandId : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public enum CarInfoValueId : Swift.Int {
  case indoorTemperature
  case outdoorTemperature
  case primaryTankLevel
  case warningLights
  case headLights
  case windowsState
  case lockState
  case batteryLevel
  case batteryDetail
  case batteryStatus
  case currentDriveDistance
  case currentSpeed
  case doorsState
  case rideState
  case odometer
  case driveDuration
  case carMode
  case secureByApp
  case notificationCarStart
  case notificationUnidentifiedDriver
  case notificationUnauthorizedOpen
  case notificationUnauthorizedEnter
  case notificationTowing
  case currentBoxTimestamp
  case carLocation
  case automaticStart
  case startAllowed
  case autoLock
  case engineSpeed
  case sirene
  case engineRunning
  case driverName
  case independentHeatingStatus
  case featureRemoteStarted
  case requestTakeover
  public static let allValues: [XMComm.CarInfoValueId]
  public static var allGsmValueIds: [XMComm.CarInfoValueId]
  public static func carInfoValueId(apiKey anApiKey: Swift.String) -> [XMComm.CarInfoValueId]
  public static func carInfoValueId(boxId aBoxId: XMComm.UartByte) -> [XMComm.CarInfoValueId]
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension XMComm.CarInfoValueId : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class XMGeneralResponse : Swift.Decodable {
  public var code: Swift.Int?
  public var message: Swift.String?
  public var id: Swift.Int?
  public var idText: Swift.String?
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
}
public enum BoxRawValueType {
  case signed, unsigned
  public static func == (a: XMComm.BoxRawValueType, b: XMComm.BoxRawValueType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ValueSupportedSource {
  case none, gsmOnly, bluetoothOnly, gsmOrBluetooth
  public static func == (a: XMComm.ValueSupportedSource, b: XMComm.ValueSupportedSource) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CommValueDefinitionType : XMComm.CommGeneralDefinitionType {
  var id: XMComm.CarInfoValueId { get set }
  var type: XMComm.CommValueType.Type { get set }
  var precision: Swift.Int? { get set }
  var rawValueType: XMComm.BoxRawValueType { get set }
  var supportedSource: XMComm.ValueSupportedSource { get }
  var isAvailableOnBluetooth: Swift.Bool { get }
  var isAvailableOnGsm: Swift.Bool { get }
  var isAvailableOnlyOnGsm: Swift.Bool { get }
  func match(apiKey anApiKey: Swift.String) -> Swift.Bool
  func match(boxId aBoxId: XMComm.UartByte) -> Swift.Bool
}
public struct CommValueDefinition : XMComm.CommValueDefinitionType {
  public var id: XMComm.CarInfoValueId
  public var type: XMComm.CommValueType.Type
  public var precision: Swift.Int?
  public var rawValueType: XMComm.BoxRawValueType
  public var boxId: XMComm.UartByte?
  public var apiName: Swift.String?
  public var description: Swift.String
  public var supportedSource: XMComm.ValueSupportedSource {
    get
  }
  public var isAvailableOnBluetooth: Swift.Bool {
    get
  }
  public var isAvailableOnGsm: Swift.Bool {
    get
  }
  public var isAvailableOnlyOnGsm: Swift.Bool {
    get
  }
  public var isAvailableOnlyOnBluetooth: Swift.Bool {
    get
  }
  public func match(apiKey aKey: Swift.String) -> Swift.Bool
  public func match(boxId anId: XMComm.UartByte) -> Swift.Bool
}
public enum CarInfoValueSource {
  case bluetoothOnly, gsmOnly, bluetoothAndGsm, unknown
  public static func == (a: XMComm.CarInfoValueSource, b: XMComm.CarInfoValueSource) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CommGeneralDefinitionType : Swift.CustomStringConvertible {
  var boxId: XMComm.UartByte? { get set }
  var apiName: Swift.String? { get set }
}
extension XMComm.CommGeneralDefinitionType {
  public var source: XMComm.CarInfoValueSource {
    get
  }
}
extension XMComm.CommGeneralDefinitionType {
  public func isEqual(to anAnother: XMComm.CommGeneralDefinitionType) -> Swift.Bool
}
public protocol BleDevice {
  var uuid: Foundation.UUID? { get }
}
extension RxBluetoothKit2.Peripheral : XMComm.BleDevice {
  public var uuid: Foundation.UUID? {
    get
  }
}
public protocol CommCommandDefinitionType : XMComm.CommGeneralDefinitionType {
  var id: XMComm.CarCommandId { get set }
}
public struct CommCommandDefinition : XMComm.CommCommandDefinitionType {
  public var id: XMComm.CarCommandId
  public var boxId: Swift.UInt8?
  public var apiName: Swift.String?
  public var description: Swift.String
}
public enum DoorWindowState {
  case opened, closed, unknown
  public static func == (a: XMComm.DoorWindowState, b: XMComm.DoorWindowState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension XMComm.DoorWindowState : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct Doors : Swift.OptionSet {
  public static let none: XMComm.Doors
  public static let leftFrontDoorKnown: XMComm.Doors
  public static let leftFrontDoorState: XMComm.Doors
  public static let rightFrontDoorKnown: XMComm.Doors
  public static let rightFrontDoorState: XMComm.Doors
  public static let leftRearDoorKnown: XMComm.Doors
  public static let leftRearDoorState: XMComm.Doors
  public static let rightRearDoorKnown: XMComm.Doors
  public static let rightRearDoorState: XMComm.Doors
  public static let trunkKnown: XMComm.Doors
  public static let trunkState: XMComm.Doors
  public static let engineKnown: XMComm.Doors
  public static let engineState: XMComm.Doors
  public static let fuelKnown: XMComm.Doors
  public static let fuelState: XMComm.Doors
  public static let roofKnown: XMComm.Doors
  public static let roofState: XMComm.Doors
  public let rawValue: Swift.UInt64
  public var frontLeftState: XMComm.DoorWindowState {
    get
  }
  public var frontRightState: XMComm.DoorWindowState {
    get
  }
  public var rearLeftState: XMComm.DoorWindowState {
    get
  }
  public var rearRightState: XMComm.DoorWindowState {
    get
  }
  public var trunkState: XMComm.DoorWindowState {
    get
  }
  public var engineState: XMComm.DoorWindowState {
    get
  }
  public var fuelState: XMComm.DoorWindowState {
    get
  }
  public var roofState: XMComm.DoorWindowState {
    get
  }
  public var someUnknown: Swift.Bool {
    get
  }
  public var anyDoorOpened: Swift.Bool {
    get
  }
  public var onlyTrunkOpen: Swift.Bool {
    get
  }
  public init(rawValue aValue: Swift.UInt64)
  public typealias ArrayLiteralElement = XMComm.Doors
  public typealias Element = XMComm.Doors
  public typealias RawValue = Swift.UInt64
}
extension XMComm.Doors : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct Windows : Swift.OptionSet {
  public static let none: XMComm.Windows
  public static let leftFrontDoorKnown: XMComm.Windows
  public static let leftFrontDoorState: XMComm.Windows
  public static let rightFrontDoorKnown: XMComm.Windows
  public static let rightFrontDoorState: XMComm.Windows
  public static let leftRearDoorKnown: XMComm.Windows
  public static let leftRearDoorState: XMComm.Windows
  public static let rightRearDoorKnown: XMComm.Windows
  public static let rightRearDoorState: XMComm.Windows
  public let rawValue: Swift.UInt64
  public var frontLeftState: XMComm.DoorWindowState {
    get
  }
  public var frontRightState: XMComm.DoorWindowState {
    get
  }
  public var rearLeftState: XMComm.DoorWindowState {
    get
  }
  public var rearRightState: XMComm.DoorWindowState {
    get
  }
  public var anyWindowOpen: Swift.Bool {
    get
  }
  public init(rawValue aValue: Swift.UInt64)
  public typealias ArrayLiteralElement = XMComm.Windows
  public typealias Element = XMComm.Windows
  public typealias RawValue = Swift.UInt64
}
extension XMComm.Windows : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum LightState {
  case on, off, unknown
  public static func == (a: XMComm.LightState, b: XMComm.LightState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Lights : Swift.OptionSet {
  public static let none: XMComm.Lights
  public static let outlineKnown: XMComm.Lights
  public static let outlineState: XMComm.Lights
  public static let standardKnown: XMComm.Lights
  public static let standardState: XMComm.Lights
  public static let hiBeamKnown: XMComm.Lights
  public static let hiBeamState: XMComm.Lights
  public let rawValue: Swift.UInt64
  public var outlineState: XMComm.LightState {
    get
  }
  public var standardState: XMComm.LightState {
    get
  }
  public var hiBeamState: XMComm.LightState {
    get
  }
  public var isAnyLightsOn: Swift.Bool {
    get
  }
  public init(rawValue aRawValue: Swift.UInt64)
  public typealias ArrayLiteralElement = XMComm.Lights
  public typealias Element = XMComm.Lights
  public typealias RawValue = Swift.UInt64
}
public protocol XMCommActionValueType {
  func unsignedIntValue() -> Swift.UInt8
}
public enum TypeOfDrive : Swift.Int {
  case unknown, privateDrive, businessDrive
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension XMComm.TypeOfDrive : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol DrivePointType {
  var coordinate: CoreLocation.CLLocationCoordinate2D { get set }
  var speed: CoreLocation.CLLocationSpeed? { get set }
  var timestamp: Foundation.TimeInterval? { get set }
  var addressLines: XMComm.AddressLinesType? { get set }
  init()
}
extension XMComm.DrivePointType {
  public var location: CoreLocation.CLLocation {
    get
    set(aNewLocation)
  }
}
public protocol DriveType {
  var carId: Swift.Int { get set }
  var id: Swift.Int? { get set }
  var startDate: Foundation.Date { get set }
  var endDate: Foundation.Date { get set }
  var distance: Swift.Double { get set }
  var startPlace: Swift.String { get set }
  var startAddress: XMComm.AddressLinesType? { get set }
  var endPlace: Swift.String { get set }
  var endAddress: XMComm.AddressLinesType? { get set }
  var duration: Foundation.TimeInterval? { get set }
  var ongoing: Swift.Bool { get set }
  var driverId: Swift.String? { get set }
  var privateLevel: XMComm.PrivateLevel { get set }
  var purpose: Swift.String? { get set }
  init()
}
extension XMComm.DriveType {
  public var driveTimeString: Swift.String {
    get
  }
  public init(drive aDrive: XMComm.DriveType)
  public mutating func update(with aDrive: XMComm.DriveType, carId aCarId: Swift.Int)
}
public protocol DriveDetailType : XMComm.DriveType {
  var distanceCost: Swift.Double { get set }
  var points: [XMComm.DrivePointType] { get set }
  var startPoint: XMComm.DrivePointType? { get set }
  var averageSpeed: CoreLocation.CLLocationSpeed { get set }
  var maxSpeed: CoreLocation.CLLocationSpeed { get set }
  var driver: Swift.String { get set }
  var userName: Swift.String { get set }
  var routeType: Swift.Int { get set }
  var routeTypeName: Swift.String { get set }
  var canEdit: Swift.Bool { get set }
}
extension XMComm.DriveDetailType {
  public var totalCosts: Swift.Double {
    get
  }
  public init(driveDetail aDriveDetail: XMComm.DriveDetailType)
  public mutating func update(driveDetail aDriveDetail: XMComm.DriveDetailType)
}
public protocol DriverType {
  var idUser: Swift.String { get set }
  var firstName: Swift.String { get set }
  var lastName: Swift.String { get set }
  var externalHash: Swift.String { get set }
}
public struct ErrorMessage {
  public var title: Swift.String?
  public var message: Swift.String
  public var presentation: XMComm.ErrorMessagePresentation
  public var targets: [Swift.String]?
  public init(message aMessage: Swift.String, presentation aPresentation: XMComm.ErrorMessagePresentation = .toast, title aTitle: Swift.String? = nil, targets aTargets: [Swift.String]? = nil)
  public func canDisplay(in aVc: Swift.String?, showGeneral aShowGeneral: Swift.Bool = true) -> Swift.Bool
}
public protocol XMCommAuthorizationServiceType {
  var rawPinConfiguration: XMComm.PINConfiguration? { get set }
  var notificationPermissionAsked: RxSwift.Observable<Swift.Bool>? { get set }
  func loginWithUserName(_ aUserName: Swift.String, andPassword: Swift.String) -> RxSwift.Observable<XMComm.XMLoginResponse>
  func loginWithToken() -> RxSwift.Observable<XMComm.XMLoginResponse>
  func logout(forgetPuk aForgetPuk: Swift.Bool) -> RxSwift.Observable<Swift.Void>
  func storeNewPIN(_ aNewPIN: Swift.String?, withConfiguration: XMComm.PINConfiguration?) -> RxSwift.Observable<Swift.Void>
  func verifyPIN(_ aPIN: Swift.String, updateAuthorizationState aStateNeedUpdate: Swift.Bool) -> RxSwift.Observable<Swift.Void>
  func newNotificationToken(_ aToken: Swift.String?)
  func performLocalLogout(forgetPuk aForgetPuk: Swift.Bool, userId anUserId: Swift.String?)
  mutating func removeTemporaryStoredCredentials()
  mutating func removeSettingsNotificationsAndLocationBasedOnState()
}
extension XMComm.XMCommAuthorizationServiceType {
  public var pinConfiguration: XMComm.PINConfiguration {
    get
  }
  public func storeNewPIN(_ aNewPIN: Swift.String?) -> RxSwift.Observable<Swift.Void>
  public func verifyPIN(_ aPIN: Swift.String) -> RxSwift.Observable<Swift.Void>
  public func logout() -> RxSwift.Observable<Swift.Void>
  public func performLocalLogout()
  public mutating func performStartupAuthorizationCleanup()
}
public enum CarInfoErrorType : Swift.Error {
  case notSupportedByCar, wrongDataType, activeCarNotAvailable, valueIdNotProvided
  public static func == (a: XMComm.CarInfoErrorType, b: XMComm.CarInfoErrorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol XMCommCarInfoType {
  var defaultTimeout: Foundation.TimeInterval { get set }
}
extension XMComm.XMCommCarInfoType {
  public func endCurrentRide()
}
public protocol FuelType {
  var carId: Swift.Int { get set }
  var id: Swift.Int { get set }
  var date: Foundation.Date { get set }
  var type: Swift.String? { get set }
  var volume: Swift.Double { get set }
  var address: Swift.String? { get set }
  var addressDetail: XMComm.AddressLinesType? { get set }
  init()
}
extension XMComm.FuelType {
  public var dateString: Swift.String {
    get
  }
  public init(fuelType aFuelType: XMComm.FuelType)
  public mutating func update(fuel aFuelType: XMComm.FuelType, carId aCarId: Swift.Int)
}
public protocol FuelDetailType : XMComm.FuelType {
  var totalPrice: Swift.Double { get set }
  var unitPrice: Swift.Double? { get set }
  var fullTank: Swift.Bool { get set }
  var verified: Swift.Bool { get set }
  var location: CoreLocation.CLLocationCoordinate2D? { get set }
  var currencyCode: Swift.String { get set }
}
extension XMComm.FuelDetailType {
  public init(fuelDetailType aFuelDetail: XMComm.FuelDetailType)
  public mutating func update(fuelDetailType aFuelDetail: XMComm.FuelDetailType)
}
@_hasMissingDesignatedInitializers open class XMCommService : XMComm.XMCommCarInfoType {
  public static let instance: XMComm.XMCommService
  public var performingConnectionOrIsConnected: Swift.Bool {
    get
  }
  public var isConnected: Swift.Bool {
    get
  }
  open var notificationPermissionAsked: RxSwift.Observable<Swift.Bool>?
  open var defaultTimeout: Foundation.TimeInterval
  @objc deinit
  @available(iOS 13.0, *)
  public func bluetoothPermissionStatus() -> RxBluetoothKit2.BluetoothState
  public func startBTService()
  public func stopBTService()
  public func restartBTService()
  public func connectToCar(_ aCar: XMComm.CarWithBoxType?)
  public var bluetoothService: XMComm.BluetoothService? {
    get
  }
}
public protocol XMFuelInfoType {
  func fuelList(forCar aCar: XMComm.CarType?, from aStartDate: Foundation.Date, to anEndDate: Foundation.Date) -> RxSwift.Observable<[XMComm.FuelType]>
  func lastFuel(forCar aCar: XMComm.CarType?) -> RxSwift.Observable<XMComm.FuelDetailType?>
  func detail(fuelId aFuelId: Swift.Int) -> RxSwift.Observable<XMComm.FuelDetailType>
  func update(fuelId aFuelId: Swift.Int, detail: XMComm.FuelDetailType) -> RxSwift.Observable<Swift.Void>
  func cachedValues(forCar aCar: XMComm.CarType?, from aStartDate: Foundation.Date, to anEndDate: Foundation.Date) -> [XMComm.FuelType]
}
extension XMComm.XMFuelInfoType {
  public func fuelList(from aStartDate: Foundation.Date, to anEndDate: Foundation.Date) -> RxSwift.Observable<[XMComm.FuelType]>
  public func fuelList(forCar aCar: XMComm.CarType? = nil, year anYear: Swift.Int, month aMonth: Swift.Int) -> RxSwift.Observable<[XMComm.FuelType]>
  public func cachedValues(forCar aCar: XMComm.CarType? = nil, year anYear: Swift.Int, month aMonth: Swift.Int) -> [XMComm.FuelType]
}
public protocol XMFuelInfoTypeWithCreate : XMComm.XMFuelInfoType {
  func create(detail aDetail: XMComm.FuelDetailType, for aCar: XMComm.CarType) -> RxSwift.Observable<Swift.Void>
}
public protocol XMLogBookType {
  func driveList(forCar aCar: XMComm.CarType?, from aStartDate: Foundation.Date, to anEndDate: Foundation.Date) -> RxSwift.Observable<[XMComm.DriveType]>
  func detail(driveId aDriveId: Swift.Int) -> RxSwift.Observable<XMComm.DriveDetailType>
  func cachedValues(forCar aCar: XMComm.CarType?, from aStartDate: Foundation.Date, to anEndDate: Foundation.Date) -> [XMComm.DriveType]
  func carProfile(forCar aCar: XMComm.CarType) -> RxSwift.Observable<XMComm.XMCarProfile>
  func driveDrivers(driveId aDriveId: Swift.Int) -> RxSwift.Observable<[XMComm.DriverVO]>
}
extension XMComm.XMLogBookType {
  public func driveList(forCar aCar: XMComm.CarType? = nil, year anYear: Swift.Int, month aMonth: Swift.Int) -> RxSwift.Observable<[XMComm.DriveType]>
  public func cachedValues(forCar aCar: XMComm.CarType? = nil, year anYear: Swift.Int, month aMonth: Swift.Int) -> [XMComm.DriveType]
}
@_hasMissingDesignatedInitializers public class BluetoothService : RxSwift.ReactiveCompatible {
  public static let sharedInstance: XMComm.BluetoothService
  public var mobileDeviceGuid: Swift.String? {
    get
    set
  }
  public var carToConnect: XMComm.CarWithBoxType? {
    get
    set(aNewCarToConnect)
  }
  public func connect(publicId aPublicId: Swift.String, publicKey aPublicKey: Swift.String, temporaryKeys aTempKeys: [Swift.String] = [])
  public func disconnect()
  public var lastDateFromBox: Foundation.Date
  public var authorizedCars: [XMComm.CarWithBoxType]
  @available(iOS 13.0, *)
  public var bluetoothPermissionState: RxBluetoothKit2.BluetoothState {
    get
    set
  }
  public var internalConnectionState: XMComm.XmRxVariable<XMComm.BtConnectionState> {
    get
  }
  public var autoConnectUUID: Swift.String? {
    get
  }
  @objc deinit
  public func centralManagerDidUpdateState(_ central: CoreBluetooth.CBCentralManager)
  public func startMonitoring()
  public typealias ReactiveBase = XMComm.BluetoothService
}
extension RxSwift.Reactive where Base : UIKit.UIApplication {
  public var isActive: RxSwift.Observable<Swift.Bool> {
    get
  }
  public var applicationState: RxSwift.Observable<UIKit.UIApplication.State> {
    get
  }
}
public class XmRxVariable<T> {
  public var value: T {
    get
    set(aNewValue)
  }
  public init(_ aValue: T)
  @objc deinit
  public func asObservable() -> RxSwift.Observable<T>
}
public enum XMBluetoothError : Swift.Error {
  case missingBoxInfo
  case deviceNotAuthorized
  case unsupportedType
  case acknowledgeNotReceived
  public static func == (a: XMComm.XMBluetoothError, b: XMComm.XMBluetoothError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ErrorMessagePresentation {
  case toast, dialog
  public static func == (a: XMComm.ErrorMessagePresentation, b: XMComm.ErrorMessagePresentation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RxSwift.Reactive where Base : XMComm.BluetoothService {
  public func nearBoxes(for aDevicePublicIds: [Swift.String]? = nil) -> RxSwift.Observable<[RxBluetoothKit2.Peripheral]>
}
extension RxBluetoothKit2.Peripheral : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
open class XMCarProfile {
  open var carId: Swift.Int?
  open var authorizedUsers: [Swift.String]?
  public init?(json: XMComm.JSON)
  @objc deinit
}
extension RxSwift.ObservableType {
  public func retryOnEveryError(maximalInterval aMaxInterval: RxSwift.RxTimeInterval = .seconds(15), scheduler aScheduler: RxSwift.SchedulerType? = nil) -> RxSwift.Observable<Self.Element>
}
extension XMComm.BluetoothService {
  public var isBluetoothActive: Swift.Bool {
    get
  }
  public var performingConnectionOrIsConnected: Swift.Bool {
    get
  }
  public var isConnected: Swift.Bool {
    get
  }
}
extension Swift.RangeReplaceableCollection where Self.Element == Swift.UInt8 {
  public init?(hexString aHexString: Swift.String)
}
public protocol ReservationType {
  var idReservation: Swift.Int? { get set }
  var idCar: Swift.Int? { get set }
  var carRegistrationNumber: Swift.String? { get set }
  var carName: Swift.String? { get set }
  var timeFrom: Foundation.Date? { get set }
  var timeTo: Foundation.Date? { get set }
  var state: Swift.Int? { get set }
  var idCompany: Swift.Int? { get set }
  var driverName: Swift.String? { get set }
}
extension RxSwift.Reactive where Base : XMComm.BluetoothService {
  public var isBluetoothAvailable: RxSwift.Observable<Swift.Bool> {
    get
  }
  public var isAuthorized: RxSwift.Observable<Swift.Bool> {
    get
  }
  public var connectionState: RxSwift.Observable<XMComm.BtConnectionState> {
    get
  }
}
extension RxSwift.Reactive where Base : XMComm.BluetoothService {
  public func value(ids anIds: [XMComm.CarInfoValueId] = []) -> RxSwift.Observable<(id: XMComm.CarInfoValueId, value: XMComm.BoxValue<Any>)>
  public func subscribe(ids anIds: [XMComm.CarInfoValueId] = []) -> RxSwift.Observable<(id: XMComm.CarInfoValueId, value: XMComm.BoxValue<Any>)>
}
extension RxSwift.Observable {
  public func printDebugLog(textPrefix: Swift.String = "") -> RxSwift.Observable<Element>
}
extension RxSwift.Reactive where Base : XMComm.BluetoothService {
  public func perform(command aCommand: XMComm.CarCommandId, value aValue: XMComm.XMCommActionValueType = UInt8(1)) -> RxSwift.Observable<Swift.Void>
}
@_hasMissingDesignatedInitializers public class WarningLights : RxSwift.ReactiveCompatible {
  public static var state: Swift.Bool {
    get
  }
  public static func turnOnWarningLights(numberOfCycles aTimes: Swift.Int = 30, cycleDuration aDuration: RxSwift.RxTimeInterval = .milliseconds(500), startDelay aDelay: RxSwift.RxTimeInterval = .seconds(0))
  public static func turnOffWarningLights()
  public typealias ReactiveBase = XMComm.WarningLights
  @objc deinit
}
extension RxSwift.Reactive where Base : XMComm.WarningLights {
  public static var state: RxSwift.Observable<Swift.Bool> {
    get
  }
}
extension XMComm.BluetoothService {
  public func disconnectFromCar(stopReconnecting: Swift.Bool = false)
  public func resetAll()
  public var connectionState: XMComm.BtConnectionState {
    get
  }
}
public enum PukRequestError : Swift.Error {
  case invalidUser, missingPhone, demoPUK
  public static func == (a: XMComm.PukRequestError, b: XMComm.PukRequestError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum SecurityLockPreferences : Swift.Int {
  case lockAndSecure, onlyLock, ask
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension XMComm.SecurityLockPreferences : Swift.Equatable {
  public static func == (lhs: XMComm.SecurityLockPreferences, rhs: XMComm.SecurityLockPreferences) -> Swift.Bool
}
public enum LockOperation : Swift.UInt8 {
  case lock, unlock, softLock
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension XMComm.LockOperation : XMComm.XMCommActionValueType {
  public func unsignedIntValue() -> Swift.UInt8
}
public protocol XMCarsReservationType {
  var idCompany: Swift.Int? { get set }
  var destinationRequired: Swift.Int? { get set }
  var purposeRequired: Swift.Int? { get set }
  var authorizerRequired: Swift.Int? { get set }
  var travelerRequired: Swift.Int? { get set }
  var noteRequired: Swift.Int? { get set }
  var name: Swift.String? { get set }
  var parkingPlace: [XMComm.XMParkingPlaceForReservationType]? { get set }
  var driverName: Swift.String? { get set }
}
public protocol XMParkingPlaceForReservationType {
  var idPlace: Swift.Int? { get set }
  var name: Swift.String? { get set }
  var cars: [XMComm.XMCarForReservationType] { get set }
}
public protocol XMCarForReservationType {
  var idCar: Swift.Int? { get set }
  var carRegistrationNumber: Swift.String? { get set }
  var carName: Swift.String? { get set }
  var carRequested: Swift.Bool? { get set }
}
public protocol XMDriverTravelerType {
  var isDriver: Swift.Bool? { get set }
  var idUser: Swift.String? { get set }
  var userName: Swift.String? { get set }
  var userFirstName: Swift.String? { get set }
  var userLogin: Swift.String? { get set }
  var userAvatar: Swift.String? { get set }
}
public protocol XMReservationF2Type {
  var idCompany: Swift.Int? { get set }
  var state: Swift.Int? { get set }
  var idUserDriver: Swift.String? { get set }
  var idUserAprover: Swift.String? { get set }
  var idCar: Swift.Int? { get set }
  var timeFrom: Foundation.Date? { get set }
  var timeTo: Foundation.Date? { get set }
  var idUserTraveler: [Swift.String]? { get set }
  var destination: Swift.String? { get set }
  var purpose: Swift.String? { get set }
  var note: Swift.String? { get set }
  func toJSON() -> [Swift.String : Any]
}
public protocol XMReservationDetailType {
  var idReservation: Swift.Int? { get set }
  var idCar: Swift.Int? { get set }
  var carDefinitionName: Swift.String? { get set }
  var carRegistrationNumber: Swift.String? { get set }
  var timeFrom: Foundation.Date? { get set }
  var timeTo: Foundation.Date? { get set }
  var state: Swift.Int? { get set }
  var idUserAprover: Swift.String? { get set }
  var userLoginAprover: Swift.String? { get set }
  var firstNameAprover: Swift.String? { get set }
  var personalNumberAprover: Swift.String? { get set }
  var idUserOriginator: Swift.String? { get set }
  var userLoginOriginator: Swift.String? { get set }
  var firstNameOriginator: Swift.String? { get set }
  var personalNumberOriginator: Swift.String? { get set }
  var idUserDriver: Swift.String? { get set }
  var userLoginDriver: Swift.String? { get set }
  var firstNameDriver: Swift.String? { get set }
  var personalNumberDriver: Swift.String? { get set }
  var idUserStateChange: Swift.String? { get set }
  var userLoginStateChange: Swift.String? { get set }
  var firstNameStateChange: Swift.String? { get set }
  var personalNumberStateChange: Swift.String? { get set }
  var stateChangeTime: Foundation.Date? { get set }
  var idUserChanged: Swift.String? { get set }
  var userLoginChanged: Swift.String? { get set }
  var firstNameChanged: Swift.String? { get set }
  var personalNumberChanged: Swift.String? { get set }
  var lastChangeTime: Foundation.Date? { get set }
  var userTraveler: [XMComm.XMDriverTravelerType]? { get set }
  var canAprove: Swift.Bool? { get set }
  var destination: Swift.String? { get set }
  var purpose: Swift.String? { get set }
  var note: Swift.String? { get set }
  var parkingPlaceName: Swift.String? { get set }
  var parkingPlace: Swift.Int? { get set }
  var canEdit: Swift.Bool? { get }
  var validFrom: Swift.String? { get set }
}
public protocol XMUserProfileType {
  var status: Swift.String? { get set }
  var userId: Swift.String? { get set }
  var requirePuk: Swift.Bool? { get set }
  var fullName: Swift.String? { get set }
  var hasReservation: Swift.Bool? { get set }
}
extension XMComm.LockStateInfo : XMComm.CommValueType {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
  public init?(serverValue aServerValue: Swift.String)
  public init?(boxValue aBoxValue: [XMComm.UartByte], precision aPrecision: Swift.Int?, rawValueType aType: XMComm.BoxRawValueType)
}
public enum LockStateInfo : Swift.UInt64, Swift.Equatable, RxSwift.ReactiveCompatible {
  case unknown, unlocked, locked
  public init?(rawValue: Swift.UInt64)
  public typealias RawValue = Swift.UInt64
  public typealias ReactiveBase = XMComm.LockStateInfo
  public var rawValue: Swift.UInt64 {
    get
  }
}
extension XMComm.LockStateInfo : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol Cacheable {
  var cacheRepresentation: Swift.String? { get }
  init?(cacheRepresentation aCacheRepresentation: Swift.String?)
}
extension Swift.Int : XMComm.Cacheable {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
}
extension Swift.Int64 : XMComm.Cacheable {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
}
extension Swift.UInt64 : XMComm.Cacheable {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
}
extension Swift.String : XMComm.Cacheable {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
}
extension CoreLocation.CLLocationCoordinate2D : XMComm.Cacheable {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
}
extension UIKit.UIApplication.State : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension UIKit.UIApplication.State : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public enum CarCharacteristicId : Swift.Int {
  case primaryFuelTankCapacity
  case primaryFuelTankFuelType
  case primaryFuelTankUnits
  case primaryFuelTankConsumption
  case primaryFuelTankCostPerKm
  public static let allCharacteristics: [XMComm.CarCharacteristicId]
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (XMComm.Reachability) -> ()
  public typealias NetworkUnreachable = (XMComm.Reachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: XMComm.Reachability.NetworkStatus, b: XMComm.Reachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    @available(*, deprecated, renamed: "unavailable")
    case none
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    public static func == (a: XMComm.Reachability.Connection, b: XMComm.Reachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: XMComm.Reachability.NetworkReachable?
  public var whenUnreachable: XMComm.Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: XMComm.Reachability.Connection {
    get
  }
  public var connection: XMComm.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension XMComm.Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public struct CarCharacteristicValue<T> where T : XMComm.Cacheable {
  public var id: XMComm.CarCharacteristicId
  public var value: T
  public var date: Foundation.Date
}
public protocol AddressLinesType {
  var street: Swift.String { get set }
  var town: Swift.String { get set }
  var townWithZip: Swift.String { get set }
  init()
}
extension XMComm.AddressLinesType {
  public var addressWithoutZip: Swift.String {
    get
  }
  public var fullAddress: Swift.String {
    get
  }
  public mutating func update(with anAddressLines: XMComm.AddressLinesType)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class FuelConsumptionVO : XMComm.RoadTypeRelatedValuesVO {
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class FuelCostsVO : XMComm.RoadTypeRelatedValuesVO {
  @objc deinit
}
public enum SwiftyJSONError : Swift.Int, Swift.Error {
  case unsupportedType
  case indexOutOfBounds
  case elementTooDeep
  case wrongType
  case notExist
  case invalidJSON
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension XMComm.SwiftyJSONError : Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public enum Type : Swift.Int {
  case number
  case string
  case bool
  case array
  case dictionary
  case null
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct JSON {
  public init(data: Foundation.Data, options opt: Foundation.JSONSerialization.ReadingOptions = []) throws
  public init(_ object: Any)
  public init(parseJSON jsonString: Swift.String)
  public mutating func merge(with other: XMComm.JSON) throws
  public func merged(with other: XMComm.JSON) throws -> XMComm.JSON
  public var type: XMComm.`Type` {
    get
  }
  public var error: XMComm.SwiftyJSONError? {
    get
  }
  public var object: Any {
    get
    set
  }
  @available(*, unavailable, renamed: "null")
  public static var nullJSON: XMComm.JSON {
    get
  }
  public static var null: XMComm.JSON {
    get
  }
}
public enum Index<T> : Swift.Comparable {
  case array(Swift.Int)
  case dictionary(Swift.DictionaryIndex<Swift.String, T>)
  case null
  public static func == (lhs: XMComm.Index<T>, rhs: XMComm.Index<T>) -> Swift.Bool
  public static func < (lhs: XMComm.Index<T>, rhs: XMComm.Index<T>) -> Swift.Bool
}
public typealias JSONIndex = XMComm.Index<XMComm.JSON>
public typealias JSONRawIndex = XMComm.Index<Any>
extension XMComm.JSON : Swift.Collection {
  public typealias Index = XMComm.JSONRawIndex
  public var startIndex: XMComm.JSON.Index {
    get
  }
  public var endIndex: XMComm.JSON.Index {
    get
  }
  public func index(after i: XMComm.JSON.Index) -> XMComm.JSON.Index
  public subscript(position: XMComm.JSON.Index) -> (Swift.String, XMComm.JSON) {
    get
  }
  public typealias Element = (Swift.String, XMComm.JSON)
  public typealias Indices = Swift.DefaultIndices<XMComm.JSON>
  public typealias Iterator = Swift.IndexingIterator<XMComm.JSON>
  public typealias SubSequence = Swift.Slice<XMComm.JSON>
}
public enum JSONKey {
  case index(Swift.Int)
  case key(Swift.String)
}
public protocol JSONSubscriptType {
  var jsonKey: XMComm.JSONKey { get }
}
extension Swift.Int : XMComm.JSONSubscriptType {
  public var jsonKey: XMComm.JSONKey {
    get
  }
}
extension Swift.String : XMComm.JSONSubscriptType {
  public var jsonKey: XMComm.JSONKey {
    get
  }
}
extension XMComm.JSON {
  public subscript(path: [XMComm.JSONSubscriptType]) -> XMComm.JSON {
    get
    set
  }
  public subscript(path: XMComm.JSONSubscriptType...) -> XMComm.JSON {
    get
    set
  }
}
extension XMComm.JSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: Swift.StringLiteralType)
  public init(unicodeScalarLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension XMComm.JSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
extension XMComm.JSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension XMComm.JSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension XMComm.JSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Any)...)
  public typealias Key = Swift.String
  public typealias Value = Any
}
extension XMComm.JSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension XMComm.JSON : Swift.RawRepresentable {
  public init?(rawValue: Any)
  public var rawValue: Any {
    get
  }
  public func rawData(options opt: Foundation.JSONSerialization.WritingOptions = JSONSerialization.WritingOptions(rawValue: 0)) throws -> Foundation.Data
  public func rawString(_ encoding: Swift.String.Encoding = .utf8, options opt: Foundation.JSONSerialization.WritingOptions = .prettyPrinted) -> Swift.String?
  public func rawString(_ options: [XMComm.writingOptionsKeys : Any]) -> Swift.String?
  public typealias RawValue = Any
}
extension XMComm.JSON : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension XMComm.JSON {
  public var array: [XMComm.JSON]? {
    get
  }
  public var arrayValue: [XMComm.JSON] {
    get
  }
  public var arrayObject: [Any]? {
    get
    set
  }
}
extension XMComm.JSON {
  public var dictionary: [Swift.String : XMComm.JSON]? {
    get
  }
  public var dictionaryValue: [Swift.String : XMComm.JSON] {
    get
  }
  public var dictionaryObject: [Swift.String : Any]? {
    get
    set
  }
}
extension XMComm.JSON {
  public var bool: Swift.Bool? {
    get
    set
  }
  public var boolValue: Swift.Bool {
    get
    set
  }
}
extension XMComm.JSON {
  public var string: Swift.String? {
    get
    set
  }
  public var stringValue: Swift.String {
    get
    set
  }
}
extension XMComm.JSON {
  public var number: Foundation.NSNumber? {
    get
    set
  }
  public var numberValue: Foundation.NSNumber {
    get
    set
  }
}
extension XMComm.JSON {
  public var null: Foundation.NSNull? {
    get
    set
  }
  public func exists() -> Swift.Bool
}
extension XMComm.JSON {
  public var url: Foundation.URL? {
    get
    set
  }
}
extension XMComm.JSON {
  public var double: Swift.Double? {
    get
    set
  }
  public var doubleValue: Swift.Double {
    get
    set
  }
  public var float: Swift.Float? {
    get
    set
  }
  public var floatValue: Swift.Float {
    get
    set
  }
  public var int: Swift.Int? {
    get
    set
  }
  public var intValue: Swift.Int {
    get
    set
  }
  public var uInt: Swift.UInt? {
    get
    set
  }
  public var uIntValue: Swift.UInt {
    get
    set
  }
  public var int8: Swift.Int8? {
    get
    set
  }
  public var int8Value: Swift.Int8 {
    get
    set
  }
  public var uInt8: Swift.UInt8? {
    get
    set
  }
  public var uInt8Value: Swift.UInt8 {
    get
    set
  }
  public var int16: Swift.Int16? {
    get
    set
  }
  public var int16Value: Swift.Int16 {
    get
    set
  }
  public var uInt16: Swift.UInt16? {
    get
    set
  }
  public var uInt16Value: Swift.UInt16 {
    get
    set
  }
  public var int32: Swift.Int32? {
    get
    set
  }
  public var int32Value: Swift.Int32 {
    get
    set
  }
  public var uInt32: Swift.UInt32? {
    get
    set
  }
  public var uInt32Value: Swift.UInt32 {
    get
    set
  }
  public var int64: Swift.Int64? {
    get
    set
  }
  public var int64Value: Swift.Int64 {
    get
    set
  }
  public var uInt64: Swift.UInt64? {
    get
    set
  }
  public var uInt64Value: Swift.UInt64 {
    get
    set
  }
}
extension XMComm.JSON : Swift.Comparable {
}
public func == (lhs: XMComm.JSON, rhs: XMComm.JSON) -> Swift.Bool
public func <= (lhs: XMComm.JSON, rhs: XMComm.JSON) -> Swift.Bool
public func >= (lhs: XMComm.JSON, rhs: XMComm.JSON) -> Swift.Bool
public func > (lhs: XMComm.JSON, rhs: XMComm.JSON) -> Swift.Bool
public func < (lhs: XMComm.JSON, rhs: XMComm.JSON) -> Swift.Bool
public enum writingOptionsKeys {
  case jsonSerialization
  case castNilToNSNull
  case maxObjextDepth
  case encoding
  public static func == (a: XMComm.writingOptionsKeys, b: XMComm.writingOptionsKeys) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension XMComm.JSON : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum RestResponseCode : Swift.Int {
  case unknown
  case ok
  case alreadyDone
  case missingPuk
  case forbidden
  case carNotAuthorized
  case missingPuk2
  case blockedDevice
  case invalidDevice
  case invalidUser
  case deviceNotAuthorized
  case missingPhone
  case stolenPhone
  case missingPuk4
  case missingPuk5
  case invalidDevice2
  case invalidDevice3
  case unknownPushId
  case notForDemo
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct PINConfiguration : Swift.OptionSet {
  public var rawValue: Swift.Int
  public init(rawValue aRawValue: Swift.Int)
  public static let none: XMComm.PINConfiguration
  public static let onStart: XMComm.PINConfiguration
  public static let onUnlock: XMComm.PINConfiguration
  public static let onSensitiveOperation: XMComm.PINConfiguration
  public static let allowBiometricsVerification: XMComm.PINConfiguration
  public static let allowManualCarStart: XMComm.PINConfiguration
  public typealias ArrayLiteralElement = XMComm.PINConfiguration
  public typealias Element = XMComm.PINConfiguration
  public typealias RawValue = Swift.Int
}
extension XMComm.PINConfiguration : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct VerificationCodeInfo {
  public var deviceInfo: XMComm.DeviceInformation
  public var code: Swift.String?
  public init()
  public init(device aDevice: XMComm.DeviceInformation, code aCode: Swift.String?)
  public init(installId anInstallId: Swift.String, code aCode: Swift.String?)
}
public enum ValueState {
  case undetermined, unknown, unsupported, notConnected, available
  public static func == (a: XMComm.ValueState, b: XMComm.ValueState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ValueSource : Swift.Int {
  case bluetooth, gsm, none
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol BoxValueType {
  associatedtype ValueType
  var value: Self.ValueType? { get }
  var state: XMComm.ValueState { get }
  var source: XMComm.ValueSource { get }
  var boxDate: Foundation.Date? { get }
}
extension XMComm.BoxValueType {
  public var intValue: Swift.Int? {
    get
  }
  public var doubleValue: Swift.Double? {
    get
  }
  public var boolValue: Swift.Bool? {
    get
  }
  public var stringValue: Swift.String? {
    get
  }
  public func notConnectedStatus(original anOriginalValue: Swift.Bool) -> Swift.Bool
}
public struct BoxValue<T> : XMComm.BoxValueType {
  public typealias ValueType = T
  public var value: XMComm.BoxValue<T>.ValueType?
  public let state: XMComm.ValueState
  public let source: XMComm.ValueSource
  public let boxDate: Foundation.Date?
  public init(value aValue: XMComm.BoxValue<T>.ValueType?, state aState: XMComm.ValueState, source aSource: XMComm.ValueSource, date aDate: Foundation.Date?)
}
extension RxSwift.Observable where Element : XMComm.BoxValueType {
  public func downcastTo<R>(_ aType: R.Type) -> RxSwift.Observable<R?>
  public var double: RxSwift.Observable<Swift.Double> {
    get
  }
  public var int: RxSwift.Observable<Swift.Int> {
    get
  }
  public var bool: RxSwift.Observable<Swift.Bool> {
    get
  }
  public var string: RxSwift.Observable<Swift.String> {
    get
  }
}
public class XMCarSubscriptionItem {
  public var location: XMComm.DrivePointVO?
  public var properties: [XMComm.XMCarPropertyItem]?
  public var validTo: Swift.Int?
  public var carId: Swift.Int?
  public var dateTime: Swift.Int?
  public var requestTakeOver: Swift.Bool?
  required public init()
  public init?(json aJson: XMComm.JSON)
  public init?(fromNotification aNotification: [Swift.AnyHashable : Any])
  public func processResponse(fromJson aJson: XMComm.JSON)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class CommCarService : RxSwift.ReactiveCompatible {
  public static var instance: XMComm.CommCarService
  public var rxCar: RxSwift.BehaviorSubject<XMComm.CarWithBoxType?> {
    get
    set
  }
  public var currentCar: XMComm.CarWithBoxType?
  public func disconnectCurrentCar()
  public typealias ReactiveBase = XMComm.CommCarService
  @objc deinit
}
extension Swift.Optional where Wrapped == Swift.String {
  public var nonEmptyString: Swift.String? {
    get
  }
}
extension XMComm.BluetoothService {
  public func scanActiveCarProximity(disposedBy aBag: RxSwift.DisposeBag? = nil)
}
extension Swift.Collection where Self.Element == Swift.UInt8 {
  public var hexString: Swift.String {
    get
  }
  public func toHexString(formatted anIsUsingFormatting: Swift.Bool) -> Swift.String
}
public protocol CarCapabilityType {
  var identifier: Swift.Int { get set }
  var boxProperties: [XMComm.BoxPropertyType] { get set }
}
public protocol BoxPropertyType {
  var key: Swift.String { get set }
  var accessibleViaGsm: Swift.Bool { get set }
  var canBeChangedViaGsm: Swift.Bool { get set }
  var accessibleViaBt: Swift.Bool { get set }
  var canBeChangedViaBt: Swift.Bool { get set }
}
extension XMComm.BoxPropertyType {
  public mutating func update(with aProperty: XMComm.BoxPropertyType)
}
extension XMComm.CarInfoValueId {
  public var definition: XMComm.CommValueDefinitionType {
    get
  }
}
public enum RidePermission : Swift.UInt64 {
  case notAllowed, allowed, allowedEmergencyMode
  public init?(rawValue: Swift.UInt64)
  public typealias RawValue = Swift.UInt64
  public var rawValue: Swift.UInt64 {
    get
  }
}
public protocol CommValueType : XMComm.Cacheable {
  init?(serverValue aServerValue: Swift.String)
  init?(boxValue aBoxValue: [XMComm.UartByte], precision aPrecision: Swift.Int?, rawValueType aType: XMComm.BoxRawValueType)
}
extension Swift.Double : XMComm.CommValueType {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
  public init?(serverValue aServerValue: Swift.String)
  public init?(boxValue aBoxValue: [XMComm.UartByte], precision aPrecision: Swift.Int?, rawValueType aType: XMComm.BoxRawValueType)
}
extension Swift.Bool : XMComm.CommValueType {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
  public init?(serverValue aServerValue: Swift.String)
  public init?(boxValue aBoxValue: [XMComm.UartByte], precision aPrecision: Swift.Int?, rawValueType aType: XMComm.BoxRawValueType)
  public init?(intValue anInt: Swift.UInt64)
}
extension Swift.UInt : XMComm.CommValueType {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
  public init?(serverValue aServerValue: Swift.String)
  public init?(boxValue aBoxValue: [XMComm.UartByte], precision aPrecision: Swift.Int?, rawValueType aType: XMComm.BoxRawValueType)
}
extension XMComm.BatteryStateCategory : XMComm.CommValueType {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
  public init?(serverValue aServerValue: Swift.String)
  public init?(boxValue aBoxValue: [XMComm.UartByte], precision aPrecision: Swift.Int?, rawValueType aType: XMComm.BoxRawValueType)
}
public func XMLog(_ aMessage: Swift.String, functionName: Swift.StaticString = #function, fileName: Swift.StaticString = #file, lineNumber: Swift.Int = #line)
public func XMLogError(_ aMessage: Swift.String, functionName: Swift.StaticString = #function, fileName: Swift.StaticString = #file, lineNumber: Swift.Int = #line)
public enum XMLogLevel : Swift.UInt {
  case verbose, debug, info, warning, error, severe, none
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
public struct XMLogger {
  public var enableConsoleLog: Swift.Bool {
    get
    set
  }
  public var logLevel: XMComm.XMLogLevel {
    get
    set
  }
  public var fileDestination: Swift.String? {
    get
    set
  }
  public var queue: Dispatch.DispatchQueue
  public var logUrls: [Foundation.URL]? {
    get
  }
  public static var defaultLogger: XMComm.XMLogger
  public init()
  public func verbose(_ aMessage: Swift.String?, functionName aFunctionName: Swift.StaticString = #function, fileName aFileName: Swift.StaticString = #file, lineNumber aLineNumber: Swift.Int = #line)
  public func debug(_ aMessage: Swift.String?, functionName aFunctionName: Swift.StaticString = #function, fileName aFileName: Swift.StaticString = #file, lineNumber aLineNumber: Swift.Int = #line)
  public func info(_ aMessage: Swift.String?, functionName aFunctionName: Swift.StaticString = #function, fileName aFileName: Swift.StaticString = #file, lineNumber aLineNumber: Swift.Int = #line)
  public func warning(_ aMessage: Swift.String?, functionName aFunctionName: Swift.StaticString = #function, fileName aFileName: Swift.StaticString = #file, lineNumber aLineNumber: Swift.Int = #line)
  public func error(_ aMessage: Swift.String?, functionName aFunctionName: Swift.StaticString = #function, fileName aFileName: Swift.StaticString = #file, lineNumber aLineNumber: Swift.Int = #line)
  public func severe(_ aMessage: Swift.String?, functionName aFunctionName: Swift.StaticString = #function, fileName aFileName: Swift.StaticString = #file, lineNumber aLineNumber: Swift.Int = #line)
}
@_hasMissingDesignatedInitializers public class ErrorMessageCenter : RxSwift.ReactiveCompatible {
  public static let shared: XMComm.ErrorMessageCenter
  public func add(errorMessage aMessage: XMComm.ErrorMessage)
  public func messages(forName aVcName: Swift.String? = nil, popFromSource aShouldPop: Swift.Bool = true) -> [XMComm.ErrorMessage]
  public var errorMessage: RxSwift.PublishSubject<Swift.String>
  public typealias ReactiveBase = XMComm.ErrorMessageCenter
  @objc deinit
}
extension XMComm.BatteryStateCategorySimplified : XMComm.CommValueType {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
  public init?(serverValue aServerValue: Swift.String)
  public init?(boxValue aBoxValue: [XMComm.UartByte], precision aPrecision: Swift.Int?, rawValueType aType: XMComm.BoxRawValueType)
}
extension XMComm.Doors : XMComm.CommValueType {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
  public init?(serverValue aServerValue: Swift.String)
  public init?(boxValue aBoxValue: [XMComm.UartByte], precision aPrecision: Swift.Int?, rawValueType aType: XMComm.BoxRawValueType)
}
extension XMComm.Windows : XMComm.CommValueType {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
  public init?(serverValue aServerValue: Swift.String)
  public init?(boxValue aBoxValue: [XMComm.UartByte], precision aPrecision: Swift.Int?, rawValueType aType: XMComm.BoxRawValueType)
}
public enum LocationIdentifiers : Swift.String {
  case infoLastLocation
  case infoPrevLocation
  case infoLastLocationEventTime
  case infoMaximumRegionSize
  case infoAuthorization
  case allowsBackgroundLocationUpdates
  case startMonitoringVisits
  case startUpdatingLocation
  case distanceFilter
  case locationRadius
  case regionNotifications
  case actionDisableUpdatingBackground
  case regions
  case regionShowMap
  case regionAddCurrent
  case regionDeleteAll
  case restartLocationService
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension XMComm.Lights : XMComm.CommValueType {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
  public init?(serverValue aServerValue: Swift.String)
  public init?(boxValue aBoxValue: [XMComm.UartByte], precision aPrecision: Swift.Int?, rawValueType aType: XMComm.BoxRawValueType)
}
extension XMComm.CarMode : XMComm.CommValueType {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
  public init?(serverValue aServerValue: Swift.String)
  public init?(boxValue aBoxValue: [XMComm.UartByte], precision aPrecision: Swift.Int?, rawValueType aType: XMComm.BoxRawValueType)
}
extension UIKit.UILabel {
  @_Concurrency.MainActor(unsafe) convenience public init(text: Swift.String)
}
extension CoreLocation.CLLocation {
  public class func distance(from: CoreLocation.CLLocationCoordinate2D, to: CoreLocation.CLLocationCoordinate2D) -> CoreLocation.CLLocationDistance
}
extension CoreLocation.CLLocationCoordinate2D {
  public var descriptionWithLimitedPrecision: Swift.String {
    get
  }
}
extension MapKit.MKMapView {
  @_Concurrency.MainActor(unsafe) public func zoomToUserLocation()
}
extension XMComm.RidePermission : XMComm.CommValueType {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
  public init?(serverValue aServerValue: Swift.String)
  public init?(boxValue aBoxValue: [XMComm.UartByte], precision aPrecision: Swift.Int?, rawValueType aType: XMComm.BoxRawValueType)
}
public enum CommandExecutionState : RxSwift.ReactiveCompatible {
  case notExecuting, executing
  public static var defaultTimeout: Swift.Double
  public static var gsmDelay: Swift.Double
  public static var defaultNotificationDuration: Swift.Double
  public static var btService: XMComm.BluetoothService
  public static var timeoutScheduler: RxSwift.SchedulerType
  public static var current: XMComm.CommandExecutionState {
    get
  }
  public static func startCommandExecution(delay aDelay: Foundation.TimeInterval = CommandExecutionState.defaultTimeout) -> Swift.Bool
  public static func == (a: XMComm.CommandExecutionState, b: XMComm.CommandExecutionState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ReactiveBase = XMComm.CommandExecutionState
  public var hashValue: Swift.Int {
    get
  }
}
extension RxSwift.Reactive where Base == XMComm.CommandExecutionState {
  public static var currentState: RxSwift.Observable<XMComm.CommandExecutionState> {
    get
  }
  public static var performingCommand: RxSwift.Observable<Swift.Bool> {
    get
  }
}
extension XMComm.BatteryStateDetail : XMComm.CommValueType {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
  public init?(serverValue aServerValue: Swift.String)
  public init?(boxValue aBoxValue: [XMComm.UartByte], precision aPrecision: Swift.Int?, rawValueType aType: XMComm.BoxRawValueType)
  public static func getBatteryStateDetail(volts aVolts: Swift.Double) -> XMComm.BatteryStateDetail
}
public enum BatteryStateStatus : Swift.UInt {
  case steady, afterCharging, charging, discharging, disconnected
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
extension XMComm.BatteryStateStatus : XMComm.CommValueType {
  public var cacheRepresentation: Swift.String? {
    get
  }
  public init?(serverValue aServerValue: Swift.String)
  public init?(boxValue aBoxValue: [XMComm.UartByte], precision aPrecision: Swift.Int?, rawValueType aType: XMComm.BoxRawValueType)
  public init?(cacheRepresentation aCacheRepresentation: Swift.String?)
}
extension XMComm.BtConnectionState : Swift.Equatable {}
extension XMComm.BtConnectionState : Swift.Hashable {}
extension XMComm.CarMode : Swift.Equatable {}
extension XMComm.CarMode : Swift.Hashable {}
extension XMComm.CarMode : Swift.RawRepresentable {}
extension XMComm.XMLoginError : Swift.Equatable {}
extension XMComm.XMLoginError : Swift.Hashable {}
extension XMComm.XMSerializationError : Swift.Equatable {}
extension XMComm.XMSerializationError : Swift.Hashable {}
extension XMComm.XMRestError : Swift.Equatable {}
extension XMComm.XMRestError : Swift.Hashable {}
extension XMComm.ValueRequestType : Swift.Equatable {}
extension XMComm.ValueRequestType : Swift.Hashable {}
extension XMComm.CarBoxStatus : Swift.Equatable {}
extension XMComm.CarBoxStatus : Swift.Hashable {}
extension XMComm.CarBoxStatus : Swift.RawRepresentable {}
extension XMComm.OSType : Swift.Equatable {}
extension XMComm.OSType : Swift.Hashable {}
extension XMComm.OSType : Swift.RawRepresentable {}
extension XMComm.Device.Orientation : Swift.Equatable {}
extension XMComm.Device.Orientation : Swift.Hashable {}
extension XMComm.Device.CameraType : Swift.Equatable {}
extension XMComm.Device.CameraType : Swift.Hashable {}
extension XMComm.PrivateLevel : Swift.Equatable {}
extension XMComm.PrivateLevel : Swift.Hashable {}
extension XMComm.PrivateLevel : Swift.RawRepresentable {}
extension XMComm.BatteryStateDetail : Swift.Equatable {}
extension XMComm.BatteryStateDetail : Swift.Hashable {}
extension XMComm.BatteryStateDetail : Swift.RawRepresentable {}
extension XMComm.BatteryStateCategory : Swift.Equatable {}
extension XMComm.BatteryStateCategory : Swift.Hashable {}
extension XMComm.BatteryStateCategory : Swift.RawRepresentable {}
extension XMComm.BatteryStateCategorySimplified : Swift.Equatable {}
extension XMComm.BatteryStateCategorySimplified : Swift.Hashable {}
extension XMComm.BatteryStateCategorySimplified : Swift.RawRepresentable {}
extension XMComm.CarCommandId : Swift.Equatable {}
extension XMComm.CarCommandId : Swift.Hashable {}
extension XMComm.CarCommandId : Swift.RawRepresentable {}
extension XMComm.CarInfoValueId : Swift.Equatable {}
extension XMComm.CarInfoValueId : Swift.Hashable {}
extension XMComm.CarInfoValueId : Swift.RawRepresentable {}
extension XMComm.BoxRawValueType : Swift.Equatable {}
extension XMComm.BoxRawValueType : Swift.Hashable {}
extension XMComm.ValueSupportedSource : Swift.Equatable {}
extension XMComm.ValueSupportedSource : Swift.Hashable {}
extension XMComm.CarInfoValueSource : Swift.Equatable {}
extension XMComm.CarInfoValueSource : Swift.Hashable {}
extension XMComm.DoorWindowState : Swift.Equatable {}
extension XMComm.DoorWindowState : Swift.Hashable {}
extension XMComm.LightState : Swift.Equatable {}
extension XMComm.LightState : Swift.Hashable {}
extension XMComm.TypeOfDrive : Swift.Equatable {}
extension XMComm.TypeOfDrive : Swift.Hashable {}
extension XMComm.TypeOfDrive : Swift.RawRepresentable {}
extension XMComm.CarInfoErrorType : Swift.Equatable {}
extension XMComm.CarInfoErrorType : Swift.Hashable {}
extension XMComm.XMBluetoothError : Swift.Equatable {}
extension XMComm.XMBluetoothError : Swift.Hashable {}
extension XMComm.ErrorMessagePresentation : Swift.Equatable {}
extension XMComm.ErrorMessagePresentation : Swift.Hashable {}
extension XMComm.PukRequestError : Swift.Equatable {}
extension XMComm.PukRequestError : Swift.Hashable {}
extension XMComm.SecurityLockPreferences : Swift.Hashable {}
extension XMComm.SecurityLockPreferences : Swift.RawRepresentable {}
extension XMComm.LockOperation : Swift.Equatable {}
extension XMComm.LockOperation : Swift.Hashable {}
extension XMComm.LockOperation : Swift.RawRepresentable {}
extension XMComm.LockStateInfo : Swift.Hashable {}
extension XMComm.LockStateInfo : Swift.RawRepresentable {}
extension XMComm.CarCharacteristicId : Swift.Equatable {}
extension XMComm.CarCharacteristicId : Swift.Hashable {}
extension XMComm.CarCharacteristicId : Swift.RawRepresentable {}
@available(*, unavailable, renamed: "Connection")
extension XMComm.Reachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension XMComm.Reachability.NetworkStatus : Swift.Hashable {}
extension XMComm.Reachability.Connection : Swift.Equatable {}
extension XMComm.Reachability.Connection : Swift.Hashable {}
extension XMComm.SwiftyJSONError : Swift.Equatable {}
extension XMComm.SwiftyJSONError : Swift.Hashable {}
extension XMComm.SwiftyJSONError : Swift.RawRepresentable {}
extension XMComm.`Type` : Swift.Equatable {}
extension XMComm.`Type` : Swift.Hashable {}
extension XMComm.`Type` : Swift.RawRepresentable {}
extension XMComm.writingOptionsKeys : Swift.Equatable {}
extension XMComm.writingOptionsKeys : Swift.Hashable {}
extension XMComm.RestResponseCode : Swift.Equatable {}
extension XMComm.RestResponseCode : Swift.Hashable {}
extension XMComm.RestResponseCode : Swift.RawRepresentable {}
extension XMComm.ValueState : Swift.Equatable {}
extension XMComm.ValueState : Swift.Hashable {}
extension XMComm.ValueSource : Swift.Equatable {}
extension XMComm.ValueSource : Swift.Hashable {}
extension XMComm.ValueSource : Swift.RawRepresentable {}
extension XMComm.RidePermission : Swift.Equatable {}
extension XMComm.RidePermission : Swift.Hashable {}
extension XMComm.RidePermission : Swift.RawRepresentable {}
extension XMComm.XMLogLevel : Swift.Equatable {}
extension XMComm.XMLogLevel : Swift.Hashable {}
extension XMComm.XMLogLevel : Swift.RawRepresentable {}
extension XMComm.LocationIdentifiers : Swift.Equatable {}
extension XMComm.LocationIdentifiers : Swift.Hashable {}
extension XMComm.LocationIdentifiers : Swift.RawRepresentable {}
extension XMComm.CommandExecutionState : Swift.Equatable {}
extension XMComm.CommandExecutionState : Swift.Hashable {}
extension XMComm.BatteryStateStatus : Swift.Equatable {}
extension XMComm.BatteryStateStatus : Swift.Hashable {}
extension XMComm.BatteryStateStatus : Swift.RawRepresentable {}
